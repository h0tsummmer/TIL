# Loop pattern
## loop의 종류
1. iterator
2. recursive

## Todo를 만들어보자
1. design을 보고 어떤 모델이 필요하고 메소드를 만드는지 생각을 하자.
2. entity를 뽑아내기(-> task, taskList)
3. 의존성이 제일 적은애부터 만들어가자
  why? 기능이 없고, 수정시 여파가 제일 낮다
4. 인터페이스 설계
  - 캡슐화가 잘 되어있는지 신경쓰기!
  - 내부의 값을 어떻게 하는지는 모르고 인터페이스만 노출함.
5. sort
  - 위임을 통해 처리. 책임이 누구에게 있는지를 확실하게 하자~
  - 캡슐화를 하면(퍼블릭 메소드만 공개) 나중에 메소드의 동작이 바뀌어도 수정의 여파가 없음.(이름은 동일하니까!)
6. (외부에 공개되는)메소드는 인자가 없는게 제일 좋다. 인자를 넘김으로서 의존성이 생기니까.
7. 생성자를 캡슐화하기 => 팩토리 함수를 만들어가자
  - constructor에 대한 추상화층 확보
  - 생성자를 부르기 전에 한번 더 간섭 가능.
  - 수정해도 하나의 버퍼층이 더 생기게 됨
8. 객체지향 vs 함수형 프로그래밍
  - 값 : 인자를 넘기거나 리턴할 때 모두 복사, 값으로 동가를 평가.
  - 객체지향 : 참조로 넘김. 메모리의 주소로 동가를 평가.
      - 단, 편의를 위해 엔트리(입구)에만 값을 받을 수 있게 할 수 있다. (반드시 여기서 값을 객체 컨텍스트로 바꿔줘야 함)
      - 객체의 필드에만 값을 허용함. 객체의 상태만 값을 확인!
9. '중복을 제거하는 것!'이 우리의 가장 큰 목표
  - 뷰에 현혹되지 않기~ 기능에 현혹되지 않기~ 데이터의 관점에서 중복은 없는지 확인해보자.
  - 역할 인식 다시 검토함으로써 중복을 제거해야 한다.
  - 역할 분리 | -- | 병합
10. composite 패턴
  - recursive를 돌리는 약속을 정하고, 약속하고 그걸로 계속 돌리도록 함
  - 종류에 따라 분기가 생기는 경우에는 상속 관계로 메소드를 강제해서 다른 메소드를 불러 실현하도록 함
  ex. 파일의 검색 시스템
  - 파일 : search가 자기랑 일치하는지 확인해서 일치하면 배열에 자길 리턴
  - 폴더 : 자기 파일 리스트를 돌면서 search 함수에 해당하는 애들을 뽑아서 확인
          this.childeren.filder(f=>f.search(v).length)
   모델이 compsite라면 그걸 소비하는 측도 recursive하게 처리해야 한다
